---
title: '告别提示词，拥抱上下文工程【译文】'
authors:
    - Philipp Schmid
date: '2025-07-04T10:44:47+08:00'
hero: /images/post/2025-07/context_engineering_hero.webp
excerpt: 大多数 AI 智能体的失败本质上是上下文之失，而非模型之过。
tags:
    - AI
    - context engineering
    - prompt
draft: false
---

**原文链接**： [The New Skill in AI is Not Prompting, It's Context Engineering](https://www.philschmid.de/context-engineering)

**原文发布日期**： 2025-06-30

**翻译**： Gemini 2.5 Pro

---

“上下文工程”是 AI 领域一个势头正劲的新概念。行业焦点正从“提示词工程”全面转向一个更宏大、更强大的领域：**上下文工程**。Shopify 创始人 [Tobi Lutke](https://x.com/tobi/status/1935533422589399127) 将其精辟地定义为“旨在提供所有必要上下文，从而让大语言模型有能力解决特定任务的一门艺术”。此言不虚。

随着 AI 智能体的崛起，我们向其“有限工作记忆”中灌注何种信息，变得至关重要。我们日益清晰地看到，决定智能体成败关键的，正是你所供给的上下文质量。如今，大多数智能体的失败，已非模型之过，实为上下文之失。

## 什么是上下文？

要理解上下文工程，我们必须先拓宽对“上下文”的认知。它远不止是发给大语言模型的那一条提示词，而是模型在生成回应前所能看到的一切信息总和。

![context_engineering](/images/post/2025-07/context_engineering.webp)

- **指令 / 系统提示词：** 用于设定模型核心行为的初始指令集，其中可包含具体范例、行为准则等。
- **用户提示词：** 用户下达的当前任务或提出的具体问题。
- **状态 / 历史记录 ( 短期记忆 )：** 当前对话的全程记录，包括迄今为止用户与模型的所有交互。
- **长期记忆：** 一个跨越多次对话、不断累积的持久化知识库，存储着习得的用户偏好、过往项目纪要，或是需要长期记住的特定事实。
- **检索信息 (RAG)：** 从外部文档、数据库或 API 中实时获取的、与特定问题相关的最新知识。
- **可用工具：** 模型可以调用的所有函数或内置工具的清晰定义（如 `check_inventory`、`send_email`）。
- **结构化输出：** 对模型响应格式的预设规范，例如要求返回一个 JSON 对象。

## 为何它至关重要：从“廉价演示”到“惊艳产品”

打造高效 AI 智能体的秘诀，与代码的繁复无关，而完全取决于所供给的上下文质量。一个“廉价的演示”与一个能带来“惊艳”体验的智能体，其根本区别就在于此。设想一个 AI 助手需要根据一封简单的邮件来安排会议：

> 嘿，问一下你明天有空碰个头吗？

**“廉价演示”型智能体** 获得的上下文极度匮乏，它只看得到用户的请求。即便其代码功能完善——成功调用了大语言模型并返回了结果——其输出也毫无帮助，像个机器人：

> 感谢您的信息。我明天有空。请问您希望约在什么时间？

**“惊艳的”智能体** 则由丰沛的上下文驱动。其代码的核心任务并非琢磨*如何*回应，而是*去聚合*大语言模型达成目标所需的一切信息。在调用大语言模型前，系统会主动将以下信息注入上下文：

- **你的日历**（显示明天会议已排满）。
- **你与此人的过往邮件**（用于判断应采用的非正式沟通口吻）。
- **你的联系人列表**（识别出对方是位重要伙伴）。
- **可供调用的工具**，如 `发送会议邀请` 或 `发送邮件`。

然后，它才能生成这样人性化的回复：

> 嘿，吉姆！我明天日程完全排满了，会一个接一个。周四上午倒是有空，你看方便吗？我先发个邀请给你，时间合不合适告诉我一声。

这其中的魔力，并非源于更聪明的模型或更精巧的算法，而在于为恰当的任务，提供了恰如其分的上下文。这正是上下文工程的价值所在。智能体的失败，归根结底是上下文之失，而非模型之过。

## 从提示词工程到上下文工程

那么，到底什么是上下文工程？如果说“提示词工程”专注于在单一文本字符串中打造完美的指令，那么上下文工程的范畴则要宽广得多。简而言之：

> 上下文工程是一门系统设计学科，它研究如何动态地、在恰当的时间、以恰当的格式、提供恰当的信息与工具，从而赋予大语言模型完成任务所需的一切。

上下文工程具有以下特点：

- **它是一个系统，而非一个字符串：** 上下文不是静态的提示词模板，而是由一个在主模型调用*之前*运行的**系统**所生成的动态输出。
- **它是动态的：** 上下文是为当前任务即时生成、量身定制的。这次请求可能需要日历数据，下一次则可能需要邮件内容或网络搜索结果。
- **它关乎时机与内容的精准匹配：** 其核心使命是确保模型不错失任何关键细节（遵循“垃圾进，垃圾出”原则），这意味着只在必要且有益时，才提供相应的知识（信息）和能力（工具）。
- **格式至关重要：** 信息的呈现方式直接影响效果。一份精炼的摘要远胜于原始数据的堆砌；一个定义清晰的工具接口远优于一条含糊不清的指令。

## 结论

构建强大而可靠的 AI 智能体，成功的关键已不再是找到某个神奇的提示词或寄望于模型更新，而在于对上下文的精心构建：在正确的时间、以正确的格式，提供正确的信息与工具。这已然是一项跨职能的挑战，它要求团队深入理解业务用例、明确输出目标，并对所有必要信息进行结构化组织，从而让大语言模型得以“完成任务”。

## 致谢

本文的写作成稿，得益于深入的人工调研，并从下列优秀资源中汲取了灵感与信息：

- [Tobi Lutke 的推文](https://x.com/tobi/status/1935533422589399127)
- [Karpathy 的推文](https://x.com/karpathy/status/1937902205765607626)
- 文章[《“上下文工程”的兴起》](https://blog.langchain.com/the-rise-of-context-engineering/)
- 文章[《掌控你的上下文窗口》](https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-03-own-your-context-window.md)
- Simon Willison 撰写的[《上下文工程》](https://simonwillison.net/2025/Jun/27/context-engineering/)
- 文章[《面向智能体的上下文工程》](https://rlancemartin.github.io/2025/06/23/context_engineering/) 
